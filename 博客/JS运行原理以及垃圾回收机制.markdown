#JS运行原理
JavaScript 是单线程、事件驱动的解释型语言，其执行过程可分为 编译阶段、执行阶段、事件循环阶段 三大部分，由引擎（如 V8）自动完成。

1. 编译与执行上下文 在代码运行前，引擎会先将源码解析为 AST（抽象语法树），并进行变量提升与作用域链构建。 执行上下文分为：
全局执行上下文：程序启动时创建，浏览器中对应 window 对象。
函数执行上下文：函数调用时创建，包含局部变量、参数、作用域链等。
块级执行上下文（ES6+）：由 let、const 声明的块级作用域生成。
执行上下文通过**执行上下文栈（ECS）**管理，遵循 LIFO 原则。
2. 调用栈与变量提升 调用栈记录函数调用顺序，函数执行完毕会出栈。
var 声明会提升到作用域顶部，初始化为 undefined。
函数声明整体提升，可在声明前调用。
let、const 存在暂时性死区，不会被初始化。
3. 事件循环与任务队列 JavaScript 的异步机制依赖 事件循环（Event Loop）：
宏任务（Macro Task）：整体代码、setTimeout、setInterval、I/O 等。
微任务（Micro Task）：Promise.then、queueMicrotask、MutationObserver 等。
执行顺序：
执行一个宏任务（同步代码）。
清空所有微任务队列。
取下一个宏任务，重复上述过程。
示例：
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("End");
// 输出顺序: Start → End → Promise → Timeout
4. 闭包与内存管理 闭包是函数与其外部作用域的组合，可在外部函数执行完后继续访问其变量。 V8 引擎使用 标记-清除 与 分代回收策略自动管理内存，但闭包若长期引用无用对象会导致内存泄漏，需手动释放引用。
5. 核心总结
编译阶段：变量提升、作用域链构建。
执行阶段：调用栈管理同步任务。
事件循环：协调异步任务执行顺序，微任务优先于宏任务。
理解这些机制有助于解决 异步顺序混乱、变量提升陷阱、内存泄漏 等常见问题。

#垃圾回收机制
JS中内存的分配和回收都是自动完成的，内存在不使用时会被垃圾回收机制自动回收。
1.全局变量一般不会回收。（关闭页面回收）
2.一般情况下，局部变量的值，不用了，会被自动回收掉。

##内存泄漏：
程序中分配的内存由于某种原因，程序未被释放或无法释放。
